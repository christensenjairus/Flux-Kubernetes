apiVersion: helm.toolkit.fluxcd.io/v2beta2
kind: HelmRelease
metadata:
  name: nextcloud
  namespace: nextcloud
spec:
  interval: 30m
  install:
    timeout: 20m # takes a while to initialize when it has the RWX volume
  upgrade:
    timeout: 20m # takes a while to because each pod rolls individually
  chart:
    spec:
      chart: nextcloud
      version: "4.6.x"
      sourceRef:
        kind: HelmRepository
        name: nextcloud
        namespace: nextcloud
      interval: 12h
  values:

    ## Official nextcloud image version
    ## ref: https://hub.docker.com/r/library/nextcloud/tags/
    ##
    image:
      repository: nextcloud
      flavor: apache
      # default is generated by flavor and appVersion
      tag: # production-apache # this was blank originally
      pullPolicy: IfNotPresent
      # pullSecrets:
      #   - myRegistrKeySecretName

    nameOverride: ""
    fullnameOverride: ""
    podAnnotations: { }
    deploymentAnnotations: { }
    deploymentLabels: { }

    # Number of replicas to be deployed
    replicaCount: 3

    ## Allowing use of ingress controllers
    ## ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
    ##
    ingress:
      enabled: true
      className: nginx-public
      annotations: #{ }
        cert-manager.io/cluster-issuer: letsencrypt
        nginx.ingress.kubernetes.io/ssl-redirect: "true"
        nginx.ingress.kubernetes.io/custom-http-errors: "400,401,403,404,405,407,408,409,410,411,412,413,418,429,500,502,503,504,505"
        # Keep this in sync with the README.md:
        nginx.ingress.kubernetes.io/server-snippet: |-
          server_tokens off;
          proxy_hide_header X-Powered-By;
          rewrite ^/.well-known/webfinger /index.php/.well-known/webfinger last;
          rewrite ^/.well-known/nodeinfo /index.php/.well-known/nodeinfo last;
          rewrite ^/.well-known/host-meta /public.php?service=host-meta last;
          rewrite ^/.well-known/host-meta.json /public.php?service=host-meta-json;
          location = /.well-known/carddav {
            return 301 $scheme://$host/remote.php/dav;
          }
          location = /.well-known/caldav {
            return 301 $scheme://$host/remote.php/dav;
          }
          location = /robots.txt {
            allow all;
            log_not_found off;
            access_log off;
          }
          location ~ ^/(?:build|tests|config|lib|3rdparty|templates|data)/ {
            deny all;
          }
          location ~ ^/(?:autotest|occ|issue|indie|db_|console) {
            deny all;
          }
        nginx.ingress.kubernetes.io/proxy-body-size: 4G
        kubernetes.io/tls-acme: "true"
        nginx.ingress.kubernetes.io/cors-allow-headers: "X-Forwarded-For"
        nginx.ingress.kubernetes.io/enable-cors: "true"
      tls:
        - secretName: christensencloud.us-tls
          hosts:
            - christensencloud.us
      labels: {}
      path: /
      pathType: Prefix


    # Allow configuration of lifecycle hooks
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/
    lifecycle: { }
    # postStartCommand: []
    # preStopCommand: []

    phpClientHttpsFix:
      enabled: true
      protocol: https

    nextcloud:
      host: christensencloud.us
      username: ""
      password: ""
      ## Use an existing secret
      existingSecret:
        enabled: true
        secretName: nextcloud-credentials
        usernameKey: nextcloud-username
        passwordKey: nextcloud-password
        tokenKey: nextcloud-token
        smtpUsernameKey: smtp-username
        smtpPasswordKey: smtp-password
        smtpHostKey: smtp-host
      update: 1
      # If web server is not binding default port, you can define it
      containerPort: 80
      datadir: /var/www/html/data
      persistence:
        subPath:
      mail:
        enabled: true
        fromAddress: noreply
        domain: christensencloud.us
        smtp:
          host: ""
          secure: ssl
          port: 465
          authtype: LOGIN
          name: ""
          password: ""
      # PHP Configuration files
      # Will be injected in /usr/local/etc/php/conf.d for apache image and in /usr/local/etc/php-fpm.d when nginx.enabled: true
      phpConfigs: #{ }
        # I've heard you should(?) use failover=distribute here, but I'm trying this. Let's see what breaks. Also change in the redis-cluster.config.php file
        redis-cluster.ini: |-
          session.save_handler = rediscluster
          session.save_path = "seed[]=nextcloud-redis-leader:6379&timeout=2&read_timeout=2&failover=distribute&persistent=1"
          redis.session.locking_enabled = 1
          redis.session.lock_retries = -1
          redis.session.lock_wait_time = 10000

      # Default config files
      # IMPORTANT: Will be used only if you put extra configs, otherwise default will come from nextcloud itself
      # Default configurations can be found here: https://github.com/nextcloud/docker/tree/master/16.0/apache/config
      defaultConfigs:
        # To protect /var/www/html/config
        .htaccess: true # might need to turn this off for fpm (instead of Apache) to function?
        # Redis default configuration
        redis.config.php: false #true # I wrote out a custom one below
        # Apache configuration for rewrite urls
        apache-pretty-urls.config.php: true
        # Define APCu as local cache
        apcu.config.php: true
        # Apps directory configs
        apps.config.php: true
        # Used for auto configure database
        autoconfig.php: true
        # SMTP default configuration
        smtp.config.php: true
      # Extra config files created in /var/www/html/config/
      # ref: https://docs.nextcloud.com/server/15/admin_manual/configuration_server/config_sample_php_parameters.html#multiple-config-php-file
      configs: #{ }
        # Log Levels: 0=DEBUG, 1=INFO, 2=WARN, 3=ERROR, 4=FATAL
        # Uncomment when you're having issues. This file is right there when you exec into the pod.
        logging.config.php: |-
          <?php
          $CONFIG = array (
            'log_type' => 'file',
            'logfile' => 'nextcloud.log',
            'loglevel' => 2,
            'logdateformat' => 'F d, Y H:i:s'
            );
          ?>

        proxy.config.php: |-
          <?php
          $CONFIG = array (
            'trusted_proxies' => array(
              0 => '127.0.0.1',
              1 => '10.0.0.0/24',
              2 => '10.0.6.0/24',
            ),
            'forwarded_for_headers' => array('HTTP_X_FORWARDED_FOR'),
            'overwriteprotocol' => 'https'
          );
          ?>

        # I've heard you should(?) use FAILOVER_ERROR here, but I'm trying this. Let's see what breaks. Also change in the redis-cluster.ini file
        redis-cluster.config.php: |-
          <?php 
          $CONFIG = [
            'memcache.distributed' => '\\OC\\Memcache\\Redis',
            'memcache.locking' => '\\OC\\Memcache\\Redis',
            'redis.cluster' => [
              'seeds' => [
                'nextcloud-redis-leader:6379'
              ],
              'timeout' => 0.0,
              'read_timeout' => 0.0,
              'failover_mode' => \RedisCluster::FAILOVER_DISTRIBUTE
            ],
          ];
          ?>

        # I've taken the standard trusted domains and added one that's necessary for the exporter to work
        trusted-domains.config.php: |-
          <?php 
          $CONFIG = [
            'trusted_domains' =>
            array (
              0 => 'localhost',
              1 => 'christensencloud.us',
              2 => 'nextcloud.nextcloud.svc.cluster.local'
            ),
          ];
          ?>

        other-settings.config.php: |-
          <?php 
          $CONFIG = [
            'skeletondirectory' => '',
            'defaultapp' => 'files,dashboard',
            'maintenance_window_start' => 8,
            'filelocking.enabled' => true,
          ];
          ?>

        oidc.config.php: |-
          <?php 
          $CONFIG = [
            'allow_user_to_change_display_name' => false,
            'lost_password_link' => 'disabled',
            'oidc_login_provider_url' => 'https://auth.christensencloud.us',
            'oidc_login_client_id' => getenv('OIDC_CLIENT_ID'),
            'oidc_login_client_secret' => getenv('OIDC_CLIENT_SECRET'),
            'oidc_login_auto_redirect' => true,
            'oidc_login_end_session_redirect' => true,
            'oidc_login_button_text' => 'Log in with Authelia',
            'oidc_login_hide_password_form' => true,
            'oidc_login_use_id_token' => true,
            'oidc_login_attributes' =>
            array (
              'id' => 'preferred_username',
              'name' => 'name',
              'mail' => 'email',
              'groups' => 'groups',
            ),
            'oidc_login_default_group' => 'nextcloud-everyone',
            'oidc_login_use_external_storage' => false,
            'oidc_login_scope' => 'openid profile email groups',
            'oidc_login_proxy_ldap' => false,
            'oidc_login_disable_registration' => false,
            'oidc_login_redir_fallback' => false,
            'oidc_login_alt_login_page' => 'assets/login.php',
            'oidc_login_tls_verify' => true,
            'oidc_create_groups' => false,
            'oidc_login_webdav_enabled' => false,
            'oidc_login_password_authentication' => false,
            'oidc_login_public_key_caching_time' => 86400,
            'oidc_login_min_time_between_jwks_requests' => 10,
            'oidc_login_well_known_caching_time' => 86400,
            'oidc_login_update_avatar' => false,
            'oidc_login_code_challenge_method' => 'S256'
          ];
          ?>

      # For example, to use S3 as primary storage
      # ref: https://docs.nextcloud.com/server/13/admin_manual/configuration_files/primary_storage.html#simple-storage-service-s3
      #
      #  configs:
      #    s3.config.php: |-
      #      <?php
      #      $CONFIG = array (
      #        'objectstore' => array(
      #          'class' => '\\OC\\Files\\ObjectStore\\S3',
      #          'arguments' => array(
      #            'bucket'     => 'my-bucket',
      #            'autocreate' => true,
      #            'key'        => 'xxx',
      #            'secret'     => 'xxx',
      #            'region'     => 'us-east-1',
      #            'use_ssl'    => true
      #          )
      #        )
      #      );

      # Hooks for auto configuration
      # Here you could write small scripts which are placed in `/docker-entrypoint-hooks.d/<hook-name>/helm.sh`
      # ref: https://github.com/nextcloud/docker?tab=readme-ov-file#auto-configuration-via-hook-folders
      hooks:
        pre-installation:
        post-installation:
        pre-upgrade:
        post-upgrade:
        before-starting:

      ## Strategy used to replace old pods
      ## IMPORTANT: use with care, it is suggested to leave as that for upgrade purposes
      ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#strategy
      strategy:
      #  type: Recreate # this is the original, mentioned in the 'important' note above
        type: RollingUpdate
        rollingUpdate:
          maxSurge: 1 # roll one at a time
          maxUnavailable: 0 # keep three up at all times

      ##
      ## Extra environment variables
      extraEnv:
        - name: PHP_MEMORY_LIMIT
          value: 8192M
        - name: PHP_UPLOAD_LIMIT
          value: 8192M
        - name: OIDC_CLIENT_ID
          valueFrom:
            secretKeyRef:
              name: nextcloud-credentials
              key: oidc-client-id
        - name: OIDC_CLIENT_SECRET
          valueFrom:
            secretKeyRef:
              name: nextcloud-credentials
              key: oidc-client-secret

      # Extra init containers that runs before pods start.
      extraInitContainers: [ ]
      #  - name: do-something
      #    image: busybox
      #    command: ['do', 'something']

      # Extra sidecar containers.
      extraSidecarContainers: [ ]
      #  - name: nextcloud-logger
      #    image: busybox
      #    command: [/bin/sh, -c, 'while ! test -f "/run/nextcloud/data/nextcloud.log"; do sleep 1; done; tail -n+1 -f /run/nextcloud/data/nextcloud.log']
      #    volumeMounts:
      #    - name: nextcloud-data
      #      mountPath: /run/nextcloud/data

      # Extra mounts for the pods. Example shown is for connecting a legacy NFS volume
      # to NextCloud pods in Kubernetes. This can then be configured in External Storage
      extraVolumes:
      #  - name: nfs
      #    nfs:
      #      server: "10.0.0.1"
      #      path: "/nextcloud_data"
      #      readOnly: false
        - name: nextcloud-apache-config
          configMap:
            defaultMode: 420
            name: nextcloud-apache-config
      extraVolumeMounts:
      #  - name: nfs
      #    mountPath: "/legacy_data"
        - mountPath: /etc/apache2/conf-enabled/remoteip.conf
          name: nextcloud-apache-config
          subPath: remoteip.conf

      # Set securityContext parameters for the nextcloud CONTAINER only (will not affect nginx container).
      # For example, you may need to define runAsNonRoot directive
      securityContext: { }
      #   runAsUser: 33
      #   runAsGroup: 33
      #   runAsNonRoot: true
      #   readOnlyRootFilesystem: false

      # Set securityContext parameters for the entire pod. For example, you may need to define runAsNonRoot directive
      podSecurityContext: { }
      #   runAsUser: 33
      #   runAsGroup: 33
      #   runAsNonRoot: true
      #   readOnlyRootFilesystem: false

    nginx:
      ## You need to set an fpm version of the image for nextcloud if you want to use nginx!
      enabled: false
      image:
        repository: nginx
        tag: alpine
        pullPolicy: IfNotPresent
      containerPort: 80

      config:
        # This generates the default nginx config as per the nextcloud documentation
        default: true
        # custom: |-
        #     worker_processes  1;..

      resources: { }

      # Set nginx container securityContext parameters. For example, you may need to define runAsNonRoot directive
      securityContext: { }
      # the nginx alpine container default user is 82
      #   runAsUser: 82
      #   runAsGroup: 33
      #   runAsNonRoot: true
      #   readOnlyRootFilesystem: true

      ## Extra environment variables
      extraEnv: [ ]
      #  - name: SOME_ENV
      #    value: ENV_VALUE

    internalDatabase:
      enabled: false
      name: nextcloud

    ##
    ## External database configuration
    ##
    externalDatabase:
      enabled: true

      ## Supported database engines: mysql or postgresql
      type: postgresql #mysql

      ## Database host
      host: ""

      ## Database user
      user: ""

      ## Database password
      password: ""

      ## Database name
      database: nextcloud

      ## Use a existing secret
      existingSecret:
        enabled: true
        secretName: nextcloud-credentials
        usernameKey: db-username
        passwordKey: db-password
        hostKey: db-host
        databaseKey: db-name

    ##
    ## MariaDB chart configuration
    ## ref: https://github.com/bitnami/charts/tree/main/bitnami/mariadb
    ##
    mariadb:
      ## Whether to deploy a mariadb server from the bitnami mariab db helm chart
      # to satisfy the applications database requirements. if you want to deploy this bitnami mariadb, set this and externalDatabase to true
      # To use an ALREADY DEPLOYED mariadb database, set this to false and configure the externalDatabase parameters
      enabled: false

      auth:
        database: nextcloud
        username: nextcloud
        password: changeme
        # Use existing secret (auth.rootPassword, auth.password, and auth.replicationPassword will be ignored).
        # secret must contain the keys mariadb-root-password, mariadb-replication-password and mariadb-password
        existingSecret: ""

      architecture: standalone

      ## Enable persistence using Persistent Volume Claims
      ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
      ##
      primary:
        persistence:
          enabled: false
          # Use an existing Persistent Volume Claim (must be created ahead of time)
          # existingClaim: ""
          # storageClass: ""
          accessMode: ReadWriteOnce
          size: 8Gi

    ##
    ## PostgreSQL chart configuration
    ## for more options see https://github.com/bitnami/charts/tree/main/bitnami/postgresql
    ##
    postgresql:
      enabled: false
      global:
        postgresql:
          # global.postgresql.auth overrides postgresql.auth
          auth:
            username: ""
            password: ""
            database: nextcloud
            # Name of existing secret to use for PostgreSQL credentials.
            # auth.postgresPassword, auth.password, and auth.replicationPassword will be ignored and picked up from this secret.
            # secret might also contains the key ldap-password if LDAP is enabled.
            # ldap.bind_password will be ignored and picked from this secret in this case.
            existingSecret: ""
            # Names of keys in existing secret to use for PostgreSQL credentials
            secretKeys:
              adminPasswordKey: ""
              userPasswordKey: ""
              replicationPasswordKey: ""
      primary:
        persistence:
          enabled: false
          # Use an existing Persistent Volume Claim (must be created ahead of time)
          # existingClaim: ""
          # storageClass: ""

    ##
    ## Redis chart configuration
    ## for more options see https://github.com/bitnami/charts/tree/main/bitnami/redis
    ##

    redis:
      enabled: false
      auth:
        enabled: false
        password: ''
        # name of an existing secret with Redis® credentials (instead of auth.password), must be created ahead of time
        existingSecret: ""
        # Password key to be retrieved from existing secret
        existingSecretPasswordKey: ""
      master:
        persistence:
          size: 3Gi
          storageClass: ceph-block-2
      replica:
        replicaCount: 3
        persistence:
          size: 3Gi
          storageClass: ceph-block-2


    ## Cronjob to execute Nextcloud background tasks
    ## ref: https://docs.nextcloud.com/server/latest/admin_manual/configuration_server/background_jobs_configuration.html#cron
    ##
    cronjob:
      enabled: true

      ## Cronjob sidecar resource requests and limits
      ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
      ##
      resources: { }

      # Allow configuration of lifecycle hooks
      # ref: https://kubernetes.io/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/
      lifecycle: { }
      # postStartCommand: []
      # preStopCommand: []
      # Set securityContext parameters. For example, you may need to define runAsNonRoot directive
      securityContext: { }
      #   runAsUser: 33
      #   runAsGroup: 33
      #   runAsNonRoot: true
      #   readOnlyRootFilesystem: true

    service:
      type: ClusterIP
      port: 8080
      loadBalancerIP: ""
      nodePort: nil

    ## Enable persistence using Persistent Volume Claims
    ## ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
    ##
    persistence:
      # Nextcloud Data (/var/www/html)
      enabled: true
      annotations: { }
      ## nextcloud data Persistent Volume Storage Class
      ## If defined, storageClassName: <storageClass>
      ## If set to "-", storageClassName: "", which disables dynamic provisioning
      ## If undefined (the default) or set to null, no storageClassName spec is
      ##   set, choosing the default provisioner.  (gp2 on AWS, standard on
      ##   GKE, AWS & OpenStack)
      ##
      storageClass: "ceph-filesystem-3"

      ## A manually managed Persistent Volume and Claim
      ## Requires persistence.enabled: true
      ## If defined, PVC must be created manually before volume will be bound
      # existingClaim:

      accessMode: ReadWriteMany
      size: 1200Mi # This is just the /var/www/html folder

      ## Use an additional pvc for the data directory rather than a subpath of the default PVC
      ## Useful to store data on a different storageClass (e.g. on slower disks)
      nextcloudData:
        enabled: true
        subPath:
        annotations: { }
        existingClaim: nextcloud-data
        accessMode: ReadWriteMany
        #storageClass: "ceph-filesystem-3"
        #size: 5000Gi

    resources: #{ }
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      # limits:
      #  cpu: 100m
      #  memory: 128Mi
      requests:
        cpu: 1000m
        memory: 1024Mi

    ## Liveness and readiness probe values
    ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes
    ##

    # I've raised these values to ~10m each before they fail for the final time and restart the pod
    # Initialization alone takes around 8-9m.
    livenessProbe:
      enabled: true
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 60 #3 # raised 20x because initialization and upgrades take a while
      successThreshold: 1
    readinessProbe:
      enabled: true
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 60 #3 # raised 20x because initialization and upgrades take a while
      successThreshold: 1
    startupProbe:
      enabled: true # false
      initialDelaySeconds: 30
      periodSeconds: 10
      timeoutSeconds: 5
      failureThreshold: 60 #30 # raised 2x because initialization and upgrades take a while
      successThreshold: 1


    ## Enable pod autoscaling using HorizontalPodAutoscaler
    ## ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
    ##
    hpa:
      enabled: true
      cputhreshold: 60
      minPods: 3
      maxPods: 9

    nodeSelector:
      nodeclass: general

    tolerations: [ ]

    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/name
                    operator: In
                    values:
                      - nextcloud
              topologyKey: kubernetes.io/hostname

    ## Prometheus Exporter / Metrics
    ##
    metrics:
      enabled: true

      replicaCount: 2
      # The metrics exporter needs to know how you serve Nextcloud either http or https
      https: false
      # Use API token if set, otherwise fall back to password authentication
      # https://github.com/xperimental/nextcloud-exporter#token-authentication
      # Currently you still need to set the token manually in your nextcloud install
      token: ""
      timeout: 5s
      # if set to true, exporter skips certificate verification of Nextcloud server.
      tlsSkipVerify: false

      image:
        repository: xperimental/nextcloud-exporter
        tag: 0.6.2
        pullPolicy: IfNotPresent
        # pullSecrets:
        #   - myRegistrKeySecretName

      ## Metrics exporter resource requests and limits
      ## ref: http://kubernetes.io/docs/user-guide/compute-resources/
      ##
      # resources: {}

      ## Metrics exporter pod Annotation and Labels
      # podAnnotations: {}

      # podLabels: {}

      service:
        type: ClusterIP
        ## Use serviceLoadBalancerIP to request a specific static IP,
        ## otherwise leave blank
        # loadBalancerIP:
        annotations:
          prometheus.io/scrape: "true"
          prometheus.io/port: "9205"
        labels: { }

      ## Prometheus Operator ServiceMonitor configuration
      ##
      serviceMonitor:
        ## @param metrics.serviceMonitor.enabled Create ServiceMonitor Resource for scraping metrics using PrometheusOperator
        ##
        enabled: true

        ## @param metrics.serviceMonitor.namespace Namespace in which Prometheus is running
        ##
        namespace: ""

        ## @param metrics.serviceMonitor.namespaceSelector The selector of the namespace where the target service is located (defaults to the release namespace)
        namespaceSelector:

        ## @param metrics.serviceMonitor.jobLabel The name of the label on the target service to use as the job name in prometheus.
        ##
        jobLabel: ""

        ## @param metrics.serviceMonitor.interval Interval at which metrics should be scraped
        ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
        ##
        interval: 30s

        ## @param metrics.serviceMonitor.scrapeTimeout Specify the timeout after which the scrape is ended
        ## ref: https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
        ##
        scrapeTimeout: ""

        ## @param metrics.serviceMonitor.labels Extra labels for the ServiceMonitor
        ##
        labels: { }


    rbac:
      enabled: false
      serviceaccount:
        create: true
        name: nextcloud-serviceaccount
        annotations: { }


    ## @param securityContext for nextcloud pod @deprecated Use `nextcloud.podSecurityContext` instead
    securityContext: { }

